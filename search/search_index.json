{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Kitman is a collection of reusable logic patterns and utilities for Python projects.</p> <p>It is highly opionated and is focused around the following libraries and frameworks:</p> <ul> <li>FastAPI</li> <li>Ormar (ORM)</li> <li>Pydantic</li> </ul> <p>It simplifies integration of the libraries into fastapi and makes a ton of building blocks available for creating advanced patterns and makes it easy to keep a high code standard.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Continue by setting up the project here.</p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>To get started with Kitman, you will first need to install the library:</p> <p>In a shell run:  <code>pip install kitman</code></p>"},{"location":"getting_started/#configuration","title":"Configuration","text":"<p>In your <code>main.py</code> file (where your FastAPI app is), you will need to configure Kitman.  You can enable / disable logging, add a custom <code>SQLAlchemy</code> <code>MetaData</code> class and much more.</p> <p>Important  The configuration has to be made before any other part of the library is imported.</p> <pre><code># In main.py\nfrom kitman import configure, Settings\n\n\n# First we configure sass_toolkit\nconfigure(\n    Settings(\n        logging = {\n            \"enable\": True # Enable / Disable logging\n        }\n    )\n)\n</code></pre> <p>After we have configured the library, we can import anything we need.</p>"},{"location":"getting_started/#fastapi","title":"FastAPI","text":"<p>The next step is to decide how we want to configure our FastAPI app.  Typically, we will use Pydantic's <code>BaseSettings</code> class, so we can change configuration settings via Environment Variables.</p> <p>You have several settings options at your disposal:</p> <ul> <li><code>AppSettings</code> (required) - The base settings class. Subclass Pydantic's <code>BaseSettings</code> class and adds a few generic attributes like <code>PROJECT_NAME</code>, <code>ENV</code> and <code>SECRET</code>.</li> <li><code>CorsSettings</code> - A mixin to configure CORS. Will automatically enable <code>FastAPI</code>'s <code>CorsMiddleware</code>.</li> <li><code>PostgresSettings</code> - A mixin to configure postgres. If a database is not provided to the <code>setup</code> function, a database will automatically be made. If <code>metadata</code> is not provided when configuring Kitman, a <code>MetaData</code> instance will be created automatically.</li> </ul> <p>Each of these settings can be combined at will.  The only required class is <code>AppSettings</code>, which needs to be subclassed.</p> <pre><code># in config.py\nfrom kitman.fastapi.conf import AppSettings, CorsSettings, PostgresSettings\n\nclass Settings(AppSettings, CorsSettings, PostgresSettings):\n    pass\n\nsettings = Settings()\n</code></pre> <p>You can now configure your project using environment variables or <code>.env</code> file.</p> <p>Full list of environment variables can be found here.</p> <p>The next step is to setup the FastAPI <code>app</code> instance, so it works with all the goodies from Kitman such as automatic error responses + starting and stopping of database etc.</p> <pre><code># In main.py\n# ... code from above\n\nfrom fastapi import FastAPI\nfrom .config import settings # Import the settings variable we created before\nfrom sass_toolkit.fastapi.conf import setup\napp = FastAPI()\n\nsetup(app, settings) # Notice we don't pass the `db` kwarg, since we wan't Kitman to auto create our database.\n</code></pre> <p>Voil\u00e0! Our FastAPI app now have:</p> <ul> <li>CORS enabled</li> <li>A Postgres database connection which will be started and stopped automatically on app start and shutdown</li> <li>Error responses whenever we raise an error that subclasses <code>kitman.exceptions.Error</code>.</li> </ul>"},{"location":"Core/SDK/Example/","title":"Example","text":"<p>We need to build a SDK for our Todo API.</p> <p>Firstly, let's look a implementing a way to retrieve and list our current todos and validate + transform responses into our custom Pydantic models.</p> <pre><code># Import in all files\nfrom kitman.core import sdk\n\n# In responses.py\nclass TodoItemResponse(sdk.Response):\n\n    id: int\n    title: str\n    text: str\n\nclass TodoResponse(sdk.Response):\n    id: int\n    name: str\n    items: list[TodoItemResponse]\n\n# In requests.py\n\nclass TodoQuery(sdk.QueryParams):\n\n    created: datetime.datetime\n\n\n# In client.py\nfrom . import requests, responses\n\nclass TodoExtension(sdk.AsyncClientExtension):\n\n    @sdk.action()\n    async def get_all(self, params: requests.TodoQuery) -&gt; list[responses.TodoResponse]:\n\n        # Arguments pass to any client HTTP method will auto-unwrap Pydantic models into dictionaries\n        return self.client.get(\"todos/\", params = query)\n\n\n\nclass TodoClient(sdk.AsyncClient):\n\n    base_url = \"https://my-todos.com/\"\n\n    todos: TodoExtension\n\n# We can now run\nasync with TodoClient() as client:\n    todos: list[TodoResponse] = await client.todos.get_all( params = {\"created\": \"2022-02-07T08:00:00Z\"}) # Query will be automatically converted to TodoQuery model\n</code></pre> <p>Let's extend it so we can create new Todo's.</p> <pre><code># In requests.py\n\nclass TodoCreate(sdk.Response):\n\n    name: str\n\n\n\n# In client.py\n\nclass TodoExtension(sdk.AsyncClientExtension):\n\n    @sdk.action()\n    async def get_all(self, params: requests.TodoQuery) -&gt; list[responses.TodoResponse]:\n\n        return self.client.get(\"todos/\", params = query)\n\n\n    @sdk_action(responses = {201: TodoResponse})\n    async def create(self, data: TodoCreate) -&gt; TodoResponse:\n\n        return self.client.post(\"todos/\", json = data)\n\n\n# We can now create todos\n\nasync with TodoClient() as client:\n    new_todo: TodoResponse = await client.todos.create(data = {\"name\": \"Todo Name\"}) # Data is automatically validated and coverted to TodoCreate model\n\n    # Or get raw response\n    new_todo_response: httpx.Response = await client.todos.create(data = {\"name\": \"Todo Name\"}, raw = True)\n</code></pre>"},{"location":"Core/SDK/introduction/","title":"Introduction","text":"<p>The SDK module makes it easier than ever to create expressive and easy-to-use clients with complete type support.  Everything from data and query to responses can be automatically validated based on standard types or custom <code>Pydantic</code> models.</p> <p>It also manages interoperability between <code>HTTPX</code> (Our client) and <code>Pydantic</code> (Our data validator), in the following ways:</p> <ul> <li>Inspects return type on your client methods and transforms HTTP response into the format (or a validation error is raised)</li> <li>Inspects arguments and kwargs of your method(s) and validates user input before even calling the method. Can be any type or a Pydantic model</li> <li>Automatically converts Pydantic models into dictionaries when calling <code>HTTPX</code> http methods like <code>get</code> or <code>post</code></li> </ul> <p>Of course, you can handle all of this manually if you wish to.</p> <p>When building an SDK, there are 4 major topics to consider:</p> <ul> <li>Client -&gt; The client manages global information about the SDK e.g. <code>base_url</code> for the server and <code>authentication</code> if working with a protected api.</li> <li>Client extensions -&gt; Client extensions implements logic for specific endpoint groups.</li> <li>Request data and query params -&gt; Validates request data/body and query params used before sending the request.</li> <li>Responses -&gt; Custom error handling for specific status_codes + support for validating and optionally transforming response data into Pydantic models.</li> </ul>"},{"location":"Database%20-%20SQL/models/","title":"Models","text":"<p>See an overview of utility models to easily and consitently solve common data problems.</p>"},{"location":"Database%20-%20SQL/models/#basemodel","title":"BaseModel","text":"<p>The <code>BaseModel</code> is the primary class, which should always be subclassed.  It implements the minimum required fields for a consistent data model.</p> <p>Fields </p> <ul> <li>id (UUID4) -&gt; The primary key field</li> <li>created (datetime) -&gt; A <code>datetime</code> for when the instance was created</li> <li>updated (datetime) -&gt; A <code>datetime</code> for when the instance was updated</li> </ul> <p>Example</p> <pre><code>import ormar\nfrom kitman.db import models\n\nclass MyModel(models.BaseModel):\n\n    class Meta(models.BaseMeta):\n        pass\n</code></pre>"},{"location":"Database%20-%20SQL/models/#orderablemixin","title":"OrderableMixin","text":"<p>Implements a simple ordering mechanism.  Whenever you use <code>Model.objects.filter</code> or the like, the instances will now be returned in the desired order.</p> <p>Fields </p> <ul> <li>order (SmallInteger, default = 1) -&gt; A SmallInteger where a lower value will order an item closer to the start of the list, where <code>1</code> will put the item in the very start of the list. There can be multiple items with the same <code>order</code> value.</li> </ul> <p>Meta  Implements <code>orders_by</code> which is set to <code>[\"order\"]</code></p> <p>Example</p> <pre><code>import ormar\nfrom kitman.db import models, mixins\n\nclass MyOrderableModel(models.BaseModel, mixins.OrderableMixin):\n\n    class Meta(models.BaseMeta, mixins.OrderableMixin.MetaOptions):\n        pass\n</code></pre>"},{"location":"FastAPI/configuration/","title":"Configuration","text":"<p>The <code>kitman.fastapi.conf</code> module contains a collection of setting classes that can be used to configure the FastAPI app.</p>"},{"location":"FastAPI/configuration/#app-settings-required","title":"App Settings (required)","text":"<p>The default setting class.</p> <p>Environment variables </p> <ul> <li>PROEJCT_NAME (str) - The name of your project / title of the <code>FastAPI</code> instance</li> <li>ENV (str) - Can be used to configure different environments like <code>development</code>, <code>staging</code> and <code>production</code></li> <li>SECRET (str) - A Base64 key used to encrypt secrets</li> </ul>"},{"location":"FastAPI/configuration/#corssettings","title":"CorsSettings","text":"<p>Configure cors.</p> <p>Environment variables </p> <ul> <li>BACKEND_CORS_ORIGINS (str) - A comma-separated string of CORS Origins including the protocol e.g. <code>\"http://localhost,http://127.0.0.1\"</code></li> </ul>"},{"location":"FastAPI/configuration/#postgressettings","title":"PostgresSettings","text":"<p>Configure Postgres database</p> <p>Environment variables </p> <ul> <li>POSTGRES_SERVER (str) - The hostname of your Postgres database</li> <li>POSTGRES_USER (str) - The Postgres database user</li> <li>POSTGRES_PASSWORD (str) - The Postgres database user's password</li> <li>POSTGRES_DB (str) - The name of the Postgres database</li> </ul>"},{"location":"Integrations/Redis/","title":"Redis","text":"<p>Easily integrate your service with Redis with settings management and async clients based on redis-py.</p> <p>The integration includes <code>hiredis</code> by default, which includes up to 10X performance improvements.</p>"},{"location":"Integrations/Redis/#settings","title":"Settings","text":"<p>Add support for configuring your Redis client(s) directly in your app settings with <code>kitman.ext.redis.RedisSettings</code>.</p> <p>Environment Variables</p> <p>The environment variable keys are in the format: <code>REDIS_&lt;setting_key&gt;</code> in uppercase.</p> <ul> <li><code>REDIS_HOST</code> (str, default: \"localhost\") - The hostname of the Redis server</li> <li><code>REDIS_PORT</code> (int, default: 6739) - The port of the Redis server</li> <li><code>REDIS_DB</code> (str | int, default: 0) - The database of the Redis server</li> <li><code>REDIS_USERNAME</code> (str, optional) - The username for authenticating with the Redis server</li> <li><code>REDIS_PASSWORD</code> (str, optional) - The password for authenticating with the Redis server</li> <li><code>REDIS_SSL</code> (bool, default: False) - Connect to Redis server over tls</li> </ul> <p>For further settings, please consult <code>redis-py</code>'s documentation. Any argument or keyword argument that is accepted by the <code>__init__</code> method of the <code>redis.Redis</code> client is applicable.</p> <p>Example</p> <pre><code># in conf.py\nfrom kitman.fastapi.conf import AppSettings\nfrom kitman.ext import redis\n\nclass Settings(AppSettings, redis.RedisSettings):\n    pass\n</code></pre>"},{"location":"Integrations/Redis/#usage","title":"Usage","text":"<p>The async Redis client class can be imported from <code>kitman.ext.redis.Redis</code>. It is a wrapper around <code>redis-py</code>'s <code>redis.asyncio.Redis</code> client. Please consult <code>redis-py</code>'s documentation for further usage documentation.</p> <p>Example</p> <pre><code>from app.conf import settings\nfrom kitman.ext import redis\n\nr = redis.Redis(**settings.get_redis_options())\n\nasync def get_key():\n\n    value = await r.get(\"my-key\")\n\n    return value\n\n# Or with custom options. E.g. using db=1 instead of db=0\n\nr_db1 = redis.Redis(**settings.get_redis_options(db=1))\n\nasync def get_key_from_db_1():\n\n    value = await r_db1.get(\"my-key\")\n\n    return value\n</code></pre>"}]}